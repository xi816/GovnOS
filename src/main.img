# GovnOS source code.
# See version in the file VERSION.
# See installation manual in docs/installation-manual.txt

import os;
import sys;
import datetime;
import readchar;
from copy import copy;
from time import sleep;
from dbgtools import *;

arp = 0;
screenLength = os.get_terminal_size().lines-1;
screenWidth = os.get_terminal_size().columns;
drive = "DRV";
govnosExit = False;

# Default run config
SHBUFSZ = 1024;
EBADCOL = 3;
ECRITCOL = 0;
DBGMODE = False;
while (arp < len(sys.argv)):
	if (sys.argv[arp] == "-s"):
		screenLength = int(sys.argv[arp+1]);
		arp += 1;
	elif (sys.argv[arp] == "-sw"):
		screenWidth = int(sys.argv[arp+1]);
		arp += 1;
	elif (sys.argv[arp] == "-d"):
		drive = sys.argv[arp+1];
		arp += 1;
	elif (sys.argv[arp] == "-1E"):
		EBADCOL = int(sys.argv[arp+1]);
		arp += 1;
	elif (sys.argv[arp] == "-2E"):
		ECRITCOL = int(sys.argv[arp+1]);
		arp += 1;
	elif (sys.argv[arp] == "-2s"):
		SHBUFSZ = int(sys.argv[arp+1]);
		arp += 1;
	elif (sys.argv[arp] == "-D"):
		DBGMODE = True;
	arp += 1;

shbuf = [0 for i in range(SHBUFSZ)];

# Initializing memory
MEMORY = [0 for i in range(1024)]; # disk
MEMORYD = [0 for i in range(1024)]; # ram
MEMORYC = [0 for i in range(1984)]; # program
MEMORYSD = [0 for i in range(64)]; # legacy ram

# GovnoCode binds
GC_EOF = 0x3A; # Change when GovnoCode will have a new standart
if (DBGMODE): dbg_print(f"GovnoCode EOF is set to: {nhex(GC_EOF)}");

CVWD = "*";
CUSR = "";

govnocodePage00 = ["\\0", "\\d", "\\f", "\\g", " ", "!", "?", "*", "&", "\"", "#", "@", ":", ";", "+", "-", "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "(", ")", "=", "_", "/", ".", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "EOF"];

def print00(*args, end="", sep=" "):
	print(*args, end=end, sep=sep);
	sys.stdout.flush();

def getFolds(folds, CVWD):
	foldsn = [];
	for fold in folds:
		print(folds);
		if (fold.startswith(CVWD)):
			fold = fold[len(CVWD):];
			stars = 1;
			for i in fold:
				if (i == "*"):
					stars -= 1;
			if (stars < 0):
				continue;
			foldsn.append(fold);
	return foldsn[1:];

def printScr(ss: list, scl, colors: list = [""]):
	if (len(ss) > scl):
		print("\x1B[31mError 0x0C80: not enough terminal height\x1B[0m");
	print("".join(colors), end="");
	for j in ss:
		fstr00 = "{: <" + str(screenWidth) + "}";
		print(fstr00.format(j) if len(j)<screenWidth else j[:screenWidth]);
	ssl = len(ss);
	while (ssl != scl):
		print();
		ssl += 1;

def printScr00(ss: list, scl, colors: list = [""]):
	if (len(ss) > scl):
		print("\x1B[31mError 0x0C00: not enough terminal height\x1B[0m");
	print("".join(colors), end="");
	print("\x1B[A"*scl, end="");
	for j in ss:
		fstr00 = "{: <" + str(screenWidth) + "}";
		print(fstr00.format(j) if len(j)<screenWidth else j[:screenWidth]);
	ssl = len(ss);
	while (ssl != scl):
		print(" "*screenWidth);
		ssl += 1;

def sysSOD(errorcode, col=0):
	print([["\x1B[41m", "\x1B[42m", "\x1B[43m", "\x1B[44m", "\x1B[45m", "\x1B[46m"][EBADCOL], ["\x1B[41m", "\x1B[42m", "\x1B[43m", "\x1B[44m", "\x1B[45m", "\x1B[46m"][ECRITCOL]][col], end="")
	print("                                 ");
	print("    ·     /                      ");
	print("         /                       ");
	print("         \\                       ");
	print("    ·     \\                      ");
	print("                                 ");
	print(f"Error {errorcode}                 ");
	with open(f"./man/e{errorcode[2:]}.man") as fl:
		for line in fl.read().split("\n"):
			print(f"{line: <33}");
		print("\x1B[0m");
	input();
	sys.exit(2);

def sysManual(page):
	with open(f"./man/{page:0>2}.man", "r") as fl:
		return fl.read();

def strify(l: list):
	return list(map(chr, l));

def strifyj(l: list):
	return "".join(strify(l));

def splitlsj(s: str):
	return list(map(ord, s));

def readord():
	k = readchar.readkey();
	return splitlsj(k) if len(k) > 1 else ord(k[0]);

# Function to load memory from the host hard drive
def memLoad(drive):
	rl = [];
	try:
		with open(f"./memory/{drive}/mem.dat", "r") as fl:
			mm = fl.read();
			if (mm):
				rl.append(splitlsj(mm));
			else:
				rl.append([0 for i in range(1024)]);
	except:
		sysSOD("0x00000001");
	try:
		with open(f"./memory/{drive}/memd.dat", "r") as fl:
			mm = fl.read();
			if (mm):
				rl.append(splitlsj(mm));
			else:
				rl.append([0 for i in range(1024)]);
	except:
		sysSOD("0x00000002", 1);
	try:
		with open(f"./memory/{drive}/memc.dat", "r") as fl:
			mm = fl.read();
			if (mm):
				rl.append(splitlsj(mm));
			else:
				rl.append([0 for i in range(1984)]);
	except:
		sysSOD("0x00000002", 1);
	try:
		with open(f"./memory/{drive}/memsd.dat", "r") as fl:
			mm = fl.read();
			if (mm):
				rl.append(splitlsj(mm));
			else:
				rl.append([0 for i in range(64)]);
	except:
		sysSOD("0x00000003");
	return rl;

# Function to save memory to the host hard drive
def memSave(MEM, MEMD, MEMC, MEMSD):
	with open(f"./memory/{drive}/mem.dat", "w") as fl:
		fl.write(strifyj(MEMORY));
	with open(f"./memory/{drive}/memd.dat", "w") as fl:
		fl.write(strifyj(MEMORYD));
	with open(f"./memory/{drive}/memc.dat", "w") as fl:
		fl.write(strifyj(MEMORYC));
	with open(f"./memory/{drive}/memsd.dat", "w") as fl:
		fl.write(strifyj(MEMORYSD));

# Function to dump the memory
def memDump(MEMORY, size, **kwargs):
	for i in range(size):
		print(f"|{MEMORY[i]}|", end=" ");
	if (kwargs.get("lf")):
		print();

def memDump00(MEMORY, size, **kwargs):
	tx = "";
	for i in range(size):
		tx += f"|{MEMORY[i]}|";
	if (kwargs.get("lf")):
		tx += "\n";
	return tx;

# Function to dump the memory using GovnoCode
def memDumpUnicode(MEMORY, size, **kwargs):
	mm = govnocodeToUnicode(MEMORY);
	for i in range(size):
		print(f"|{mm[i]}|", end=" ");
	if (kwargs.get("lf")):
		print();

def memDumpUnicode00(MEMORY, size, **kwargs):
	tx = "";
	mm = govnocodeToUnicode(MEMORY);
	for ix, i in enumerate(range(size)):
		tx += f"|{mm[i]: >3}|";
		if (ix % 10 == 9):
			tx += "\n"
	if (kwargs.get("lf")):
		tx += "\n";
	return tx;

# Function to put list of data into the memory
def memPut(MEMORY, ldata, stid):
	for ix, el in enumerate(ldata):
		MEMORY[stid+ix] = el;
	return MEMORY, stid+ix+1;

def govnocodeToUnicode(l: list):
	for i, j in enumerate(l):
		l[i] = govnocodePage00[j];
	return l;

def govnocodeToUnicode00(c: str):
	return govnocodePage00[c];

def govnocodeToUnicode01(l: list):
	return "".join(govnocodeToUnicode(l));

def unicodeToGovnocodeDir(l: str):
	l = list(l);
	for i, j in enumerate(l):
		if (ord(j) in range(65, 91)):
			l[i] = ord(j)-33;
		elif (ord(j) in range(48, 58)):
			l[i] = ord(j)-32;
		elif (j == "."):
			l[i] = 0x1F;
		elif (ord(j) == 42):
			l[i] = 0x07;
		else:
			print(f"\x1B[31mUnknown symbol: {hex(ord(j))}\x1B[0m");
	return l;

# Function to create a file or directory using GovnFS
def memTouch(mem, dir, name, t: str): # t=0 -> file, t=1 -> directory
	for i, j in enumerate(mem):
		if (j == GC_EOF):
			break;
	mem[i] = 0x00; # Remove the EOF to make a new entry
	if (t == 0):
		print(i);
		mem[i] = 0x02;
		mem[i+1] = 0x03;
		i += 2;
		for j,k in enumerate(unicodeToGovnocodeDir(name)):
			mem[i+j] = k;
		i += j+1;
		mem[i] = 0x03;
		i += 1;
		for j,k in enumerate(unicodeToGovnocodeDir(dir)):
			mem[i+j] = k;
		i += j+1;
		mem[i] = 0x03;
		mem[i+1] = 0x02;
		mem[i+2] = GC_EOF;
		i += 3;
	elif (t == 1):
		mem[i] = 0x01;
		mem[i+1] = 0x03;
		i += 2;
		for j,k in enumerate(unicodeToGovnocodeDir(dir)):
			mem[i+j] = k;
		i += j+1;
		for j,k in enumerate(unicodeToGovnocodeDir(name)):
			mem[i+j] = k;
		i += j+1;
		mem[i] = 0x01;
		mem[i+1] = GC_EOF;
		i += 2;
	return mem;

# Function to configure the disk from legacy configurations
def sysLegacyConfig(MEMORY, conf):
	print("\x1B[41mNO NEED OF SYSLEGACYCONFIG\x1B[0m");
	exit(1);

# Function to wipe the memory
def memorySysWipe(MEMORY):
	memsize = len(MEMORY);
	MEMORY = [0 for i in range(memsize)];
	return MEMORY;

def sysInstallBasic(MEMORY, username: str, password: list, hostname: str):
	# Installation process is split to contain user-written changes
	# 00 - user and root password
	# 01 - hostname
	# 02 - end
	installationProcess00 = [
		0x01, 0x03, 0x07, 0x01,
		0x01, 0x03, 0x07, 0x26, 0x31, 0x2F, 0x07, 0x01,
		0x02, 0x03,
			0x32, 0x24, 0x22, 0x24, 0x1F, 0x22, 0x03,
			0x07, 0x26, 0x31, 0x2F, 0x07, 0x03,
			0x31, 0x2E, 0x2E, 0x33, 0x0C # 0x04, 0x34, 0x32, 0x24, 0x31,
	];
	installationProcess01 = [
		0x02,
		0x02, 0x03,
			0x27, 0x2E, 0x32, 0x33, 0x03,
			0x07, 0x26, 0x31, 0x2F, 0x07, 0x03,
	];
	installationProcess02 = [
		0x02,
		0x01, 0x03, 0x07, 0x33, 0x2C, 0x2F, 0x07, 0x01,
		0x01, 0x03, 0x07, 0x2F, 0x31, 0x2E, 0x26, 0x07, 0x01,
		0x01, 0x03, 0x07, 0x27, 0x2E, 0x2C, 0x24, 0x07, 0x01,
		0x02, 0x03,
			0x25, 0x28, 0x2B, 0x24, 0x1F, 0x33, 0x03,
			0x07, 0x03,
			0x16, 0x19,
		0x02,
		0x01, 0x03, 0x07, 0x21, 0x2E, 0x2E, 0x33, 0x07, 0x01,
		0x02, 0x03,
			0x2F, 0x32, 0x33, 0x20, 0x31, 0x33, 0x1F, 0x22, 0x03,
			0x07, 0x21, 0x2E, 0x2E, 0x33, 0x07, 0x03,
			0x14, 0x11, 0x11, 0x04, 0x23, 0x2E, 0x07, 0x11, 0x07,
		0x02,
		GC_EOF
	];
	mem, stid = memPut(MEMORY, installationProcess00, 0);
	mem, stid = memPut(MEMORY, password[1]+[0x04]+username+[0x0C]+password[0], stid);
	mem, stid = memPut(MEMORY, installationProcess01, stid);
	mem, stid = memPut(MEMORY, hostname, stid);
	mem, stid = memPut(MEMORY, installationProcess02, stid);
	return mem;

def sysScreenUpdate():
	print(" "*5000);

def contAddr(MEMORY, FILEDIR, FILENAME):
	filestart, namestart, dirstart, insstart = fsReadFile(MEMORY, FILEDIR, FILENAME)[2:6];
	return filestart, namestart, dirstart, insstart;

def sysExecLine(MEMORY, CVWD, govnshCommand):
	gpath = govnshCommand.split();
	addinfoA = False;
	addinfo = "";
	print(gpath);
	govnshExitCode = 0;
	if (gpath[0] == "help"):
		if ((len(gpath) == 2) and (gpath[1].isdigit())):
			addinfoA = True;
			addinfo = sysManual(page=govnshCommand.split()[1]);
		elif (len(gpath) == 1):
			addinfoA = True;
			addinfo = "Use `help 0` to read the manual";
		else:
			addinfoA = True;
			addinfo = "\x1B[31mInvalid `help` | Expected 0 or 1 argument\x1B[0m";
	elif (gpath[0] == "time"):
		addinfoA = True
		dt = datetime.datetime.now();
		if (gpath[1] == "-t"):
			addinfo = f"{dt.hour}:{dt.minute}:{dt.second}";
		elif (gpath[1] == "-d"):
			addinfo = f"{dt.month}.{dt.day}.{dt.year}";
		elif (gpath[1] == "-D"):
			addinfo = f"{dt.day}";
		elif (gpath[1] == "-M"):
			addinfo = f"{dt.month}";
		elif (gpath[1] == "-Y"):
			addinfo = f"{dt.year}";
		elif (gpath[1] == "-H"):
			addinfo = f"{dt.hour}";
		elif (gpath[1] == "-m"):
			addinfo = f"{dt.minute}";
		elif (gpath[1] == "-S"):
			addinfo = f"{dt.second}";
		elif (gpath[1] == "-Ms"):
			addinfo = f"{dt.millisecond}";
	elif (gpath[0] == "wd"):
		addinfoA = True;
		if (len(gpath) > 1):
			addinfo = "\x1B[31mInvalid `wd` | Expected 0 arguments\x1B[0m";
		else:
			addinfo = CVWD;
	elif (gpath[0] == "shutdown"):
		if (len(gpath) > 1):
			addinfo = "\x1B[31mInvalid `shutdown` | Expected 0 arguments\x1B[0m";
		else:
			govnshExit = True;
	elif (gpath[0] == "he"):
		addinfoA = True;
		if (len(gpath) == 1):
			addinfo = "\n".join(fsParseHe(MEMORY, CVWD)[0]);
		elif (len(gpath) == 2):
			addinfo = "\n".join(fsParseHe(MEMORY, CVWD+govnshCommand.split()[1])[0]);
		else:
			addinfo = "\x1B[31mInvalid `he` | Expected 0 or 1 argument\x1B[0m";
	elif (gpath[0] == "inside"):
		addinfoA = True;
		if (len(gpath) == 2):
			retcode, container = fsReadFile(MEMORY, CVWD, govnshCommand.split()[1])[:2];
			if (not retcode):
				addinfo = "".join(govnocodeToUnicode(container));
			elif (retcode == 1):
				addinfo = f"\x1B[31mCould not find the file {govnshCommand.split()[1]}\x1B[0m";
		else:
			addinfo = "\x1B[31mInvalid `inside` | Expected 1 argument\x1B[0m";
	elif (gpath[0] == "dir"):
		addinfoA = True;
		if (len(gpath) == 2):
			MEMORY = memTouch(copy(MEMORY), CVWD, gpath, 1);
			addinfo = f"\x1B[32mCreated the directory {gpath}\x1B[0m";
		else:
			addinfo = "\x1B[31mInvalid `dir` | Expected 1 argument\x1B[0m";
	elif (gpath[0] == "file"):
		addinfoA = True;
		if (len(gpath) == 2):
			gpath = govnshCommand.split()[-1];
			MEMORY = memTouch(copy(MEMORY), CVWD, gpath, 0);
			addinfo = f"\x1B[32mCreated the file {gpath}\x1B[0m";
		else:
			addinfo = "\x1B[31mInvalid `file` | Expected 1 argument\x1B[0m";
	elif (gpath[0] == "ba"):
		if (len(gpath) == 1):
			if (CVWD == "*"):
				addinfoA = True;
				addinfo = f"\x1B[32mPOSHALKO 1488\x1B[0m";
			else:
				CVWD = "*".join(CVWD[:-1].split("*")[:-1])+"*";
		else:
			addinfo = "\x1B[31mInvalid `ba` | Expected 0 arguments\x1B[0m";
	elif (gpath[0] == "exit"):
		govnshExit = True;
		if (len(gpath) == 1):
			govnshExitCode = 0;
		elif (len(gpath) == 2):
			govnshExitCode = int(gpath[1]);
		else:
			addinfo = "\x1B[31mInvalid `exit` | Expected 0 or 1 argument\x1B[0m";
	elif (gpath[0] == "ren"):
		if (len(gpath) == 3):
			contaddrs = fsReadFile(MEMORY, CVWD, gpath[0]);
			print(contaddrs, CVWD, gpath[0]);
			contaddrs00 = contaddrs[0];
			contaddrs = contaddrs[2:6];
			if (contaddrs00 == 1):
				addinfo = f"\x1B[31mFile {gpath[0]} not found\x1B[0m";
			elif (len(gpath[1]) < len(gpath[0])):
				for i,j in enumerate(gpath[1]):
					MEMORY[contaddrs[1]+i] = unicodeToGovnocodeDir(gpath[1][i])[0];
				for j in range(len(gpath[0])-len(gpath[1])):
					MEMORY.pop(contaddrs[1]+i+1);
				MEMORY += [0 for i in range(len(gpath[0])-len(gpath[1]))];
			elif (len(gpath[1]) == len(gpath[0])):
				for i,j in enumerate(gpath[0]):
					MEMORY[contaddrs[1]+i] = unicodeToGovnocodeDir(gpath[1][i])[0];
			else:
				for i,j in enumerate(gpath[0]):
					MEMORY[contaddrs[1]+i] = unicodeToGovnocodeDir(gpath[1][i])[0];
				i = len(gpath[0]);
				for j in range(len(gpath[1])-len(gpath[0])):
					MEMORY.insert(contaddrs[1]+i+j, unicodeToGovnocodeDir(gpath[1][i+j])[0]);
				MEMORY = MEMORY[:-(len(gpath[1])-len(gpath[0]))];
			addinfo = "\x1B[32mFile succesfully renamed.\x1B[0m";
		else:
			addinfo = "\x1B[31mInvalid `ren` | Expected 2 arguments\x1B[0m";
	elif (gpath[0] == "rmv"):
		if (len(gpath) == 2):
			rdfl = fsReadFile(MEMORY, CVWD, govnshCommand.split()[1]);
			addinfoA = True;
			if (rdfl[0] == 0):
				MEMORY = fsRemFile(copy(MEMORY), rdfl[2])[1];
				addinfo = f"\x1B[32mRemoved file {govnshCommand.split()[1]}\x1B[0m";
			else:
				addinfo = f"\x1B[31mFile {govnshCommand.split()[1]} not found\x1B[0m";
		else:
			addinfo = "\x1B[31mInvalid `rmv` | Expected 1 argument\x1B[0m";
	elif (gpath[0] == "to"):
		addinfoA = True;
		if (len(gpath) == 2):
			if (gpath in list(map(lambda a: a[len(CVWD):], fsParseHe(MEMORY, CVWD)[1]))):
				CVWD += gpath[1];
				addinfo = f"\x1B[32mMoved to the folder {gpath}\x1B[0m";
			else:
				addinfo = f"\x1B[31mFolder not found: {govnshCommand.split()[-1]}\x1B[0m";
		else:
			addinfo = "\x1B[31mInvalid `to` | Expected 1 argument\x1B[0m";
	elif (gpath[0] == "sys.memdump"):
		addinfoA = True;
		if ((len(gpath) < 2) and (len(gpath) > 3)):
			addinfo = "\x1B[31mInvalid `sys.memdump` | Expected 1 or 2 arguments\x1B[0m";
		else:
			if (gpath[1] == "-u"):
				addinfoA = True;
				if (gpath[2].isdigit()):
					print(govnshCommand.split());
					addinfo = memDumpUnicode00(copy(MEMORY), int(gpath[2]));
				else:
					addinfo = memDumpUnicode00(copy(MEMORY), 20);
			else:
				addinfo = memDump00(MEMORY, 20);
				if (govnshCommand.split()[-1].isdigit()):
					addinfo = memDump00(MEMORY, int(govnshCommand.split()[-1]));
				else:
					addinfo = memDump00(MEMORY, 20);
	else:
		addinfoA = True;
		addinfo = f"\x1B[31mUnknown command `{gpath[0]}`\x1B[0m";
	return govnshExitCode, MEMORY, CVWD, addinfoA, addinfo;

def sysGovnSh(CVWD):
	global govnosExit, MEMORY;
	govnshCommand = "";
	govnshCList = [];
	govnshExit = False;
	GEXITCODE = 0;
	while (not govnshExit):
		pk = readord();
		addinfo = False;
		addinfoA = [];
		print00(">>\n");
		if ((pk in range(97, 123)) or (pk in range(65, 91)) or (pk in range(48, 58)) or (pk in range(33, 39)) or (pk in range(40, 43)) or pk in [44, 46, 47]):
			govnshCommand += chr(pk);
		elif (pk == 45):
			govnshCommand += "-";
		elif (pk == [27, 116]):
			govnshCommand += "þ";
		elif (pk == [27, 84]):
			govnshCommand += "Þ";
		elif (pk == 32):
			govnshCommand += " ";
		elif (pk == 10):
			print00("\n");
			GEXITCODE, MEMORY, CVWD, addinfoA, addinfo = sysExecLine(MEMORY, CVWD, govnshCommand);
			govnshCList.append(govnshCommand);
			govnshCommand = "";
		elif (pk == 127):
			if (govnshCommand):
				govnshCommand = govnshCommand[:-1];
		elif (pk == [27, 27]):
			govnshExit = True;
			govnosExit = True;
		else:
			print00("\n\x1B[31m>> Unknown key! <<\x1B[0m");
		if (addinfoA):
			printScr00([f">> {govnshCommand}_", f"Key pressed: {pk}", ""]+addinfo.split("\n"), screenLength);
		else:
			printScr00([f">> {govnshCommand}_", f"Key pressed: {pk}"], screenLength);
	return govnshCList;

def sysGravno(CVWD):
	gravnoComm = "";
	gravnomode = True;
	scr = [""]*(screenLength-7);
	# Gravno states:
	# 0 -- Normal
	# 1 -- Command
	gravnostate = 0;
	k = readord();

	while (gravnomode):
		tm = datetime.datetime.now();
		tmf = f"{tm.hour:0>2}:{tm.minute:0>2}";
		tmf00 = "GovnOS 0.126";
		tmf = ("{:}{: >"+f"{screenWidth-len(tmf00)}"+"}").format(tmf00, tmf);
		printScr00([
			tmf,
			"-"*screenWidth,
			f"{k}"
			]+scr+[
			"-"*screenWidth,
			gravnoComm+["@", "_"][gravnostate],
			"-"*screenWidth,
			"^(A)=Comm ^(W)=Term"
		], screenLength);
		k = readord();
		if (gravnostate == 0):
			if (k == [27, 81]):
				gravnomode = False;
			elif (k == 1):
				gravnostate = 1;
			elif (k == 8):
				scr = [""]*(screenLength-7);
			elif (k == 23):
				scr[0] = "Terminal";
		elif (gravnostate == 1):
			if (k == 1):
				gravnostate = 0;
			elif ((k in range(97, 123)) or (k in range(65, 91)) or (k in range(48, 58)) or (k in [32])):
				gravnoComm += chr(k);
			elif (k == 10):
				if (gravnoComm.split(" ")[0] == "echo"):
					scr[int(gravnoComm.split(" ")[1])] = " ".join(gravnoComm.split(" ")[2:]);
				elif (gravnoComm == "exit"):
					gravnomode = False;
				gravnoComm = "";
				gravnostate = 0;
			elif (k == 127):
				if (gravnoComm):
					gravnoComm = gravnoComm[:-1];
	return 0;

# Function to halt before some event
def sysHalt(event, **kwargs):
	if (event == 0):
		k = 0;
		while (k != kwargs["haltkey"]):
			k = readord();

# Filesystem things
def fsParseHe(MEMORY, CVWD):
	pos = 0;
	fsn = "";
	foldsFound = [];
	filesFound = [];
	while (MEMORY[pos] != GC_EOF):
		print(f"\x1B[32mFolders: {foldsFound}, {filesFound}. Pos: {pos}\x1B[0m");
		if (MEMORY[pos] == 0x01): # directory found
			fsn = "";
			pos += 2;
			while (MEMORY[pos] != 0x01):
				fsn += govnocodeToUnicode00(MEMORY[pos]);
				pos += 1;
			foldsFound.append(fsn);
			fsn = "";
			pos += 1;
		elif (MEMORY[pos] == 0x02): # file found
			pos += 2;
			fsn = ["", ""];
			while (MEMORY[pos] != 0x03):
				fsn[0] += govnocodeToUnicode00(MEMORY[pos]);
				pos += 1;
			pos += 1;
			while (MEMORY[pos] != 0x03):
				fsn[1] += govnocodeToUnicode00(MEMORY[pos]);
				pos += 1;
			pos += 1;
			if (fsn[1] == CVWD):
				filesFound.append(fsn[0]);
				fsn = "";
			while (MEMORY[pos] != 0x02):
				pos += 1;
			pos += 1;
		else:
			print(f"\x1B[31mUnknown symbol found while folder parsing -> {MEMORY[pos]}. {pos}\x1B[0m");
	foldsNeeded = [f"Data in {CVWD}:"]+(list(map(lambda a: f"  {a: <10}"+" DIR", getFolds(foldsFound, CVWD))))+list(map(lambda a: f"  {a: <10} FILE", filesFound));
	print(f"\x1B[32m{foldsNeeded}\x1B[0m");
	return foldsNeeded, foldsFound;

def fsReadFile(MEMORY, CVWD, FIN):
	pos = 0;
	ins = [];
	fins = "";
	fins00 = "";
	finished = False;
	FILEADDR = 69420;
	NAMEADDR = 69420;
	DIRADDR = 69420;
	INSADDR = 69420;
	while ((MEMORY[pos] != GC_EOF)):
		if (MEMORY[pos] == 0x02):
			FILEADDR = pos;
			fins = "";
			fins00 = "";
			pos += 2; # start of filename
			NAMEADDR = pos;
			while (MEMORY[pos] != 0x03):
				fins00 += govnocodeToUnicode00(MEMORY[pos]);
				pos += 1;
			pos += 1;
			DIRADDR = pos;
			while (MEMORY[pos] != 0x03):
				fins += govnocodeToUnicode00(MEMORY[pos]);
				pos += 1;
			pos += 1;
			if (fins+fins00 == CVWD+FIN): # found the file
				INSADDR = pos;
				while (MEMORY[pos] != 0x02):
					ins.append(MEMORY[pos]);
					pos += 1;
				return 0, ins, FILEADDR, NAMEADDR, DIRADDR, INSADDR;
			else:
				while (MEMORY[pos] != 0x02):
					pos += 1;
			pos += 1;
		elif (MEMORY[pos] == 0x01):
			pos += 2;
			while (MEMORY[pos] != 0x01):
				pos += 1;
			pos += 1;
		else:
			print(f"\x1B[31m-> {MEMORY[pos]}. {pos}\x1B[0m");
	return 1, ins, 69420, 69420, 69420, 69420;

def fsRemFile(MEMORY, FILESTART):
	fsz = 0;
	MEMORY.pop(FILESTART);
	while (MEMORY[FILESTART] != 0x02):
		MEMORY.pop(FILESTART);
		print(govnocodeToUnicode01(MEMORY[FILESTART-10:FILESTART+10]));
	MEMORY.pop(FILESTART);
	print(govnocodeToUnicode01(MEMORY[FILESTART-10:FILESTART+10]));
	return 0, MEMORY;

def sysReadSece(s: str):
	s = s.split(" ");
	ss = dict();
	for i,j in enumerate(s):
		ss[s[i].split(":")[0]] = s[i].split(":")[1];
	return ss;

def sysShutdown(M, MD, MC, MSD, exit=False):
	print("Shutting down...");
	memSave(M, MD, MC, MSD);
	if (exit):
		sys.exit(41);

def Govnasm(M, MD, MC, MSD):
	return 0;

# Turn on the machine (load memory)
MEMORY, MEMORYD, MEMORYC, MEMORYSD = memLoad(drive);

graphicsStart = "|----------------------------------|";
graphicsMaster = "|  GovnOS 1.1 installation master  |";
graphicsEmpty = "|                                  |";

# OS installation if it's not installed
in00 = {"host": "GOVNOS", "drive": "DRV"};
if not MEMORY[0]:
	print("\nInstallation started...");

	# Legacy shell
	gshExit = False;
	gevExit = False;
	while (not gevExit):
		printScr([
			graphicsStart,
			graphicsMaster,
			"|    Hello and thanks for choosing |",
			"|    GovnOS!                       |",
			graphicsEmpty,
			"|    Press Return to install.      |",
			"|    Or press T for term install.  |",
			graphicsStart,
			"| Ret=Install T=Terminal           |",
			graphicsStart
		], screenLength, ["\x1B[44m"]);
		key = readord();
		if (key in [0x54, 0x74]):
			gevExit = True;

	while (not gshExit):
		command = input(f"[ROOT@{in00['host']}] ");
		if (command == "exit"):
			gshExit = True;
			sysShutdown(MEMORY, MEMORYD, MEMORYC, MEMORYSD, exit=True);
		elif (command == "adduser"):
			in01 = input("Enter user: ").upper();
			in02 = input("Add a password: ").upper();
			in03 = input("Add? (Y/N, default: Y): ").upper();
			if (in03 in ["", "Y"]):
				in00["user"] = [in01, in02, 0x00];
		elif (command == "passwd"):
			in01 = input("Enter new root password: ").upper();
			in00["root"] = in01;
		elif (command == "hostname"):
			in01 = input("Enter new host name: ").upper();
			in00["host"] = in01;
		elif (command == "config-gen"):
			in01 = input("Are you sure? (Y/N): ");
			while (in01 not in ["Y", "N"]):
				in01 = input("Are you sure? (Y/N): ");
			if (in01 == "Y"):
				print("  Building a filesystem...");
				print("  Installing GovnFS Basic Memory Bootstrap...");
				MEMORY = sysInstallBasic(MEMORY, unicodeToGovnocodeDir(in00["user"][0]), (unicodeToGovnocodeDir(in00["user"][1]), unicodeToGovnocodeDir(in00["root"])), unicodeToGovnocodeDir(in00["host"]));
				print("  GovnFS installed!");
				print("  Filesystem built!");

hostname = govnocodeToUnicode01(fsReadFile(MEMORY, "*GRP*", "HOST")[1]);

print("GovnOS 0.116");
print("Loading...");
print(f"  MEMORY {len(MEMORY)} bytes +");
print(f"  MEMORY {len(MEMORYD)} bytes +");
print(f"  MEMORY {len(MEMORYC)} bytes +");
print(f"  MEMORY {len(MEMORYSD)} bytes");
print("\nGovnOS loaded!");
print(f"Welcome, {hostname}");

print("\nStarting GovnoDiM...");
usr00 = input("User: ");
usr01 = input("Password: ");

while (sysReadSece(govnocodeToUnicode01(fsReadFile(MEMORY, "*GRP*", "SECE.C")[1])).get(usr00) != usr01):
	print("Incorrect login or password!");
	usr00 = input("User: ");
	usr01 = input("Password: ");

CUSR = usr00; # Enter to the system
# If CUSR is not ROOT, spawn in *HOME* by default.
if (CUSR != "ROOT"):
	CVWD = "*HOME*";

print("\nPress Esc,C to start TyGovno command mode");
print("Press Esc,G to start Gravno graphics mode");
print("Press Esc,Esc to shutdown");

govnshCList = [];

# Native shell -> GovnOS
while (not govnosExit):
	k = readord();
	if ((k == [27, 67]) or (k == [27, 99])):
		print("\nLoading TyGovno...");
		print("TyGovno loaded!");
		print("Use `help 0` to get help");
		govnshCList = sysGovnSh(CVWD);
		print("\nPress Esc,C to start TyGovno command mode");
		print("Press Esc,G to start Gravno graphics mode");
		print("Press Esc,Esc to shutdown");
	elif ((k == [27, 71]) or (k == [27, 103])):
		print("\nLoading Gravno...");
		print("Gravno loaded!");
		sysGravno(CVWD);
		print("\nPress Esc,C to start TyGovno command mode");
		print("Press Esc,G to start Gravno graphics mode");
		print("Press Esc,Esc to shutdown");
	elif (k == [27, 27]):
		govnosExit = True;

# Shutting down
sysShutdown(MEMORY, MEMORYD, MEMORYC, MEMORYSD);

# Saving the terminal history to memory/DRV/govnCList.dat
with open(f"./memory/{drive}/govnCList.dat", "w") as fl:
	fl.write("\n".join(govnshCList));

sys.exit(61);
